// Professional PDF Generator Utility
// This file contains helper functions for generating professional corporate-grade PDFs

import jsPDF from 'jspdf';

export interface PDFPartData {
  partName: string;
  thickness?: number;
  length?: number | null;
  coatingGsm?: number;
  blackMaterialWeight?: number;
  zincAddedWeight?: number;
  totalWeight?: number;
}

export interface PDFQuotationData {
  createdBy: string;
  customerName: string;
  placeOfSupply: string;
  purpose: string;
  date: string;
  section: string;
  quantityRm: number | null;
  parts: PDFPartData[];
  fastenerMode?: 'default' | 'manual';
  fastenerWeight?: number;
  fastenerDetails?: {
    hexBoltQty: number;
    buttonBoltQty: number;
  };
  multipliers?: {
    wBeam?: number;
    post?: number;
    spacer?: number;
  };
  totalSetWeight?: number | null;
  totalWeightPerRm?: number | null;
  materialCostPerRm: number | null;
  transportCostPerRm: number | null;
  installationCostPerRm: number | null;
  totalCostPerRm: number | null;
  finalTotal: number | null;
  // Custom fields for Signages module
  customFields?: {
    boardType?: string;
    shape?: string;
    size?: number | null;
    width?: number | null;
    height?: number | null;
    sheetingType?: string;
    acpThickness?: number;
    printingType?: string;
    lamination?: boolean;
    areaSqMm?: number;
    areaSqM?: number;
    areaSqFt?: number;
    baseMaterialCostPerSqFt?: number;
    laminationCostPerSqFt?: number;
    rivetingPackagingCostPerSqFt?: number;
    overheadCostPerSqFt?: number;
    totalCostPerSqFt?: number;
    profitPercent?: number;
    quantity?: number;
    costPerPiece?: number;
    // MS Part fields
    msEnabled?: boolean;
    msPostSpec?: string | null;
    msFrameSpec?: string | null;
    msPostLengthM?: number | null;
    msFrameLengthM?: number | null;
    msPostWeightKg?: number | null;
    msFrameWeightKg?: number | null;
    msTotalMsWeightKg?: number | null;
    msRatePerKg?: number | null;
    msCostPerStructure?: number | null;
    msTotalMsCost?: number | null;
  };
}

// Helper function to generate PDF as buffer (for merging)
export async function generateProfessionalPDFBuffer(data: PDFQuotationData): Promise<Uint8Array> {
  const doc = new jsPDF();
  doc.setFont('helvetica');
  
  const pageWidth = doc.internal.pageSize.width;
  const pageHeight = doc.internal.pageSize.height;
  const marginLeft = 25;
  const marginRight = pageWidth - 25;
  const contentWidth = marginRight - marginLeft;
  const lineHeight = 8;
  
  let yPos = 30;
  
  // Helper: Format numbers without any special characters
  const formatNumber = (num: number | undefined | null): string => {
    if (num === undefined || num === null || isNaN(num)) return '0.00';
    // Convert to string with 2 decimal places
    const numStr = num.toFixed(2);
    // Split into integer and decimal parts
    const parts = numStr.split('.');
    const integerPart = parts[0];
    const decimalPart = parts[1];
    
    // Add commas for thousands separator manually
    let formattedInteger = '';
    for (let i = integerPart.length - 1, count = 0; i >= 0; i--, count++) {
      if (count > 0 && count % 3 === 0) {
        formattedInteger = ',' + formattedInteger;
      }
      formattedInteger = integerPart[i] + formattedInteger;
    }
    
    return `${formattedInteger}.${decimalPart}`;
  };
  
  // Helper: Check if new page needed
  const checkNewPage = (requiredSpace: number) => {
    if (yPos + requiredSpace > pageHeight - 50) {
      doc.addPage();
      yPos = 30;
      return true;
    }
    return false;
  };
  
  // Helper: Add consistent vertical spacing
  const addSpacing = (spacing: number = 10) => {
    yPos += spacing;
  };

  // Use the existing generateProfessionalPDF logic but return buffer instead of downloading
  // We'll call the existing function's logic here
  // For now, let's create a simplified version that generates the PDF and returns buffer
  
  // This is a placeholder - we need to copy the entire PDF generation logic here
  // but return doc.output('arraybuffer') instead of doc.save()
  
  // For now, let's use the existing function and modify it
  return await generatePDFInternal(doc, data, formatNumber, checkNewPage, addSpacing, pageWidth, pageHeight, marginLeft, marginRight, contentWidth, lineHeight);
}

async function generatePDFInternal(
  doc: jsPDF,
  data: PDFQuotationData,
  formatNumber: (num: number | undefined | null) => string,
  checkNewPage: (requiredSpace: number) => boolean,
  addSpacing: (spacing?: number) => void,
  pageWidth: number,
  pageHeight: number,
  marginLeft: number,
  marginRight: number,
  contentWidth: number,
  lineHeight: number
): Promise<Uint8Array> {
  let yPos = 30;
  
  // Copy the entire PDF generation logic from generateProfessionalPDF
  // This is a large function, so I'll need to read the full implementation
  // For now, let me create a wrapper that uses the existing function
  
  // Actually, the best approach is to refactor generateProfessionalPDF to accept a mode parameter
  // But to avoid breaking changes, let's create a new internal function that both can use
  
  // Let me read the full generateProfessionalPDF function first
  return new Promise((resolve) => {
    // We'll need to modify the existing function
    // For now, let's create a version that generates and returns buffer
    const buffer = doc.output('arraybuffer');
    resolve(new Uint8Array(buffer));
  });
}

// Existing function - keep as is for backward compatibility
export async function generateProfessionalPDF(data: PDFQuotationData, fileName: string): Promise<void> {
  // This function will be kept as is - it downloads the PDF
  // We'll create a shared internal function that both use
  const doc = new jsPDF();
  doc.setFont('helvetica');
  
  const pageWidth = doc.internal.pageSize.width;
  const pageHeight = doc.internal.pageSize.height;
  const marginLeft = 25;
  const marginRight = pageWidth - 25;
  const contentWidth = marginRight - marginLeft;
  const lineHeight = 8;
  
  let yPos = 30;
  
  // Helper: Format numbers without any special characters
  const formatNumber = (num: number | undefined | null): string => {
    if (num === undefined || num === null || isNaN(num)) return '0.00';
    const numStr = num.toFixed(2);
    const parts = numStr.split('.');
    const integerPart = parts[0];
    const decimalPart = parts[1];
    
    let formattedInteger = '';
    for (let i = integerPart.length - 1, count = 0; i >= 0; i--, count++) {
      if (count > 0 && count % 3 === 0) {
        formattedInteger = ',' + formattedInteger;
      }
      formattedInteger = integerPart[i] + formattedInteger;
    }
    
    return `${formattedInteger}.${decimalPart}`;
  };
  
  // Helper: Check if new page needed
  const checkNewPage = (requiredSpace: number) => {
    if (yPos + requiredSpace > pageHeight - 50) {
      doc.addPage();
      yPos = 30;
      return true;
    }
    return false;
  };
  
  // Helper: Add consistent vertical spacing
  const addSpacing = (spacing: number = 10) => {
    yPos += spacing;
  };

  // Continue with the rest of the PDF generation logic...
  // I need to read the full function to copy it properly
